#!/usr/bin/env bash
#~encodes existing library to mp4 with aac audio

#TODO add subtitle extraction/renaming etc..
#TODO add lolify.cfg stuff

#~ config ~#

#~ functions ~#

_help() {
    echo "
    usage:  lolify [options]

    lolify will look for a lolify.cfg file inside the source directory.
    its an optional file, that contains one flag + args per line
    if an arg is both specified when running the script and in the cfg
    file, the arg in the cfg file will take presedence, this means you can
    specify an input and output directory when running the script in a cron
    job, then if you want to change the output directory, you can override the
    option set in the cron job without having to change it
    TODO not here yet


    options:

        -h  show this message


        -a  audiotrack

            defualt=0:a:0 (the first audio track)
            (the first 0 is the input FID or file id
            the 'a' means we want audio
            the last 0 is the TID or which audio file we want


        -s  subtitletrack(TODO not here yet)

            default=none
            uses same format as -a
            0:s:0 == first subtitle track
            only subs inside the source file(mkv etc)
            all subs including external, should be automatically
            detected and renamed to match the specified name regex


        -n  name:rangeregex

            default=use difference between files as the rangeregex, leave
            everything else unchanged.
            if you want to leave file names competely unchanged pass '-r no'
            (see -r for more info)
            example:
            if you had files with the schema of 'showname disc 1 title 2.mkv',
            since the '1 title 2' is the only part that changes between files
            you would end up with something like this:
            'show name disc 1 title 2.mkv' --> 'show name disc 2.mp4


            name       - the new full name for the file with a place holder for
                         the range '%(range)s' and extension '%(ext)s'
                         example with only name:
                         '-n Anohana.%(range)s.%(ext)s:'

            rangeregex - the regular expression to match the source file
                         numbering. the default is the difference between files
                         as explained above. main use for this would be if you
                         are not changing the name but still want to strip some
                         of the default name(the 'disc' in the default example)
                         example with only rangeregex:
                         '-n :disc [0-9]* title [0-9]*'

            each can be used alone. to only use a rangeregex just use a leading
            ':' likewise if you only want to use the name formatting, just use
            a trailing ':' if you dont include the ':' the script will assume
            the argument is name format


        -r  [prefix:]range[,range2][,prefix3:range3][... ]

            default=1-x (where x is the total number of files)
            use '-r no' to use original 'diff' numbering. if you do this, and
            do not provied the '-n' flag, no filenames will be changed

            prefix  - the prefix that will go in front of the next specified
                      range, ie to get SXXEXX you would use '-r S01E:01-09'

            range   - basic range of numbers(1-23), or a single number(03)
                      the range will be 0-padded to match the 'longest' number
                      ie, 1-23 or 01-9 will result in 01, 02 etc, while
                      1-9 will result in 1, 2 etc..
                      if you have more files than ranges specified, the default
                      will be used **TODO** filling in empty spots??
                      ie. -r 03-04,S00E:01
                      would auto fill 01-02, then continue at 05-x?
                      only filling non prefix?
                      so if we had prefixes, then it would start at 01

            -r works by sorting your files, then iterating over them and
            assigning the range/numbering as speficied. accepting multiple
            ranges allows you to number for specials or scrambled discs
            for example: if you had 23 episodes the 4th ep down was special 3
            or something you might do this:
                -r S01E:01-03,S00E:03,S01E:04-x


        -t  target

            the directory w/ the non mp4s
            (the one you've got your sights on so to speak. think ln)
            default=./
            

        -d  destination

            where you want the mp4s to end up
            defualt=./lolified
    "
}

_lolify(){
    #~encode existing library

    #~re-create directory structure
    find "$source_dir" -type d -not -path "*$dest_dir*" -exec bash -c 'dest_path="$2/${1#*"$3"}"; echo "item:$dest_path"; mkdir -p "$dest_path"' - {} "$dest_dir" "$source_dir" \;

    #~encode files
    #find "$source_dir" -type f -not -path "*$dest_dir*" -exec bash -c 'dest_path="$2/${1#*"$3"}"; echo "item:$dest_path"; ffmpeg -v quiet -stats -i "$1" -map 0:v:0 -map "$4" -movflags +faststart -c:v libx264 -preset slower -crf 19 -ac 2 -c:a aac -b:a 192k "${dest_path%.*}.mp4"' - {} "$dest_dir" "$source_dir" "$audio_trackid" \;
    find "$source_dir" -type f -not -path "*$dest_dir*" -not -name "lolify.cfg" -exec bash -c 'dest_path="$2/${1#*"$3"}"; echo "item:$dest_path"; cp "$1" "${dest_path%.*}.mp4"' - {} "$dest_dir" "$source_dir" "$audio_track_id" \;
}

_destFileList() {
    #function just because i use it more than once
    find "$dest_dir" -type f
}

_stringDiff() {
    #some magic here...
    #we need to find the differences between a list of files..
    #how are we going to do that? diff.
    control_file_ext=$(_destFileList | head -n 1)
    control_file_folder="${control_file_ext%.*}"
    control_file="${control_file_folder##*'/'}"
    if [[ "${range_regex,,}" == "no" ]]; then
        while read compare_file_ext; do
            compare_file_folder="${compare_file_ext%.*}"
            compare_file="${compare_file_ext##*'/'}"
            difference=$(diff <(echo "$control_file" | grep -o .) \
                <(echo "$compare_file" | grep -o .) | grep -vE '<|>' | \
                grep -o '[0-9]*[a-z][0-9]*' | grep -o '[0-9]*')
            #grab the diff on the highest and lowest lines(the biggest diff)
            diff_end=$(printf '%s\n' "$difference" "$diff_end" | sort -n |\
                tail -n1)
            diff_start=$(printf '%s\n' "$difference" "${diff_start:-$diff_end}" | \
                sort -n | head -n1)
        done <<< $(_destFileList | sort)
        diff_pre="${control_file:0:$((diff_start - 1))}"
        diff_post="${control_file:$((diff_end - 1))}"
    else
        difference=$(echo "$control_file" | sed "s/$range_regex/D,E,L,I,M/")
        diff_pre="${difference%'D,E,L,I,M'*}"
        diff_post="${difference#*'D,E,L,I,M'}"
    fi
    echo "$diff_pre%(range)s$diff_post%(ext)s"
}

_rangeParse() {
    #parses range, creates array:
    #start    [0]   int
    #end      [1]   int
    #asc/desc [2]   int (1|-1)
    #padding  [3]   int
    #prefix   [4]   string
    #bash has a hard time passing an array to another function when some of the
    #items have spaces in them.. so we need to let the other function use this
    #very array..
    r=()
    local range="${1#*:}"
    r+=("${range%-*}")
    if [[ "${range#*-}" == 'x' ]]; then
        r+=($(_destFileList | wc -l))
    else
        r+=("${range#*-}")
    fi
    if [[ ${r[0]} -gt ${r[1]} ]]; then
        r+=(-1)
    else
        r+=(1)
    fi
    r+=("$((${#r[0]} > ${#r[1]} ? ${#r[0]} : ${#r[1]}))")
    if [[ "$1" == *":"* ]]; then
        r+=("${1%:*}")
    fi
}

_rangeBuildArray() {
    #creates array of each files 'range' number/file number
    ranged_array=()
    for i in "${range[@]}"; do
        _rangeParse "$i"
        for j in $(seq ${r[0]} ${r[2]} ${r[1]}); do
            ranged_array+=("$(printf "${r[4]}%0${r[3]}d" "$j")")
        done
    done
}

_nameBuildArray() {
    #creates array of each files 'differences'
    #the stuff that _stringDiff leaves out
    #_stringDiff setting diff_{pre,post} is a pre-req for this function
    ranged_array=()
    while read file; do
        if [[ "${range_regex,,}" == "no" ]]; then
            diff_mi="${file#*"${diff_pre}"}"
            diff_mi="${diff_mi%"${diff_post}"*}"
            ranged_array+=("$diff_mi")
        else
            ranged_array+=("$(echo "$file" |\
                sed -n "s/.*\($range_regex\).*/\1/p")")
        fi
    done <<< $(_destFileList | sort)
}

_nameFormatCheck() {
    #name_format needs to contain %(range)s and %(ext)s
    #if it does not, they will be added at the end
    if [[ ! "$name_format" == *"%(range)s"* ]]; then
        name_format="${name_format%'%(ext)s'*}%(range)s%(ext)s"
    fi
    if [[ ! "$name_format" == *"%(ext)s"* ]]; then
        name_format="${name_format}%(ext)s"
    fi
    name_pre="${name_format%'%(range)s'*}"
    name_post="${name_format#*'%(range)s'}"
    echo "$name_format"
}


_organize() {
    if [[ "${name_format,,}" == "no" ]]; then
        name_format="$(_stringDiff)"
        name_pre="$diff_pre"
        name_post="$dif_post"
    else
        _stringDiff >> /dev/null
        name_format="$(_nameFormatCheck)"
    fi
    if [[ ! "${range,,}" == "no" ]]; then
        _rangeBuildArray
        if [[ "${#ranged_array[@]}" -lt "$(_destFileList | wc -l)" ]]; then
            #attempts to fill in remaining to match index length of file array
            rp="${range[-1]}"
            rr=${ranged_array[-1]}
            range+=("${rp%:*}:$((${rr//${rp%:*}/} + 1))-x")
            _rangeBuildArray
        fi
    else
        _nameBuildArray
    fi

    local file_iter=0
    _destFileList | sort | while read file; do
        file_ext=".${file##*.}"
        file_name="${file%.*}"
        new_name="$(echo $(echo "$name_format" | \
            sed "s/%(range)s/${ranged_array[$file_iter]}/" |\
            sed "s/%(ext)s/${file_ext}/"))"
        echo "${file%/*}/$new_name"
        ((file_iter++))
    done
}


#~ script_start ~#

while [ "$1" != "" ]; do
    case $1 in
        *help)
            _help
            exit
           ;;
       -a)
           shift
           audio_track_id="$1"
           ;;
       -s)
           shift
           subtitle_track_id="$1"
           ;;
       -n)
           shift
           name="$1"
           ;;
       -r)
           shift
           IFSOLD="$IFS"
           IFS=','
           read -r -a range <<< "$1"
           IFS="$IFSOLD"
           ;;
       -t)
           shift
           target_dir="$1"
           ;;
       -d)
           shift
           dest_dir="$1"
           ;;
       *)
           echo "unknown option: '$1'"
           _help
           exit 1
           ;;
   esac
   shift
done
#defaults
audio_track_id="${audio_track_id:-0:a:0}"
subtitle_track_id="${subtitle_track_id:-0:s:0}"
if [[ "$name" == *":"* ]]; then
    name_format="${name%:*}"
    name_format="${name_format:-no}"
    range_regex="${name#*:}"
    range_regex="${range_regex:-no}"
else
    name_format="${name:-no}"
    range_regex="no"
fi
if [[ -z $range ]]; then
    range=(1-x)
fi
source_dir="${source_dir:-.}"
dest_dir="${dest_dir:-./lolified}"

echo audio_track_id:$audio_track_id
echo subtitle_track_id:$subtitle_track_id
echo name_format:$name_format
echo range_regex:$range_regex
echo range:${range[@]}
echo source:$source_dir
echo dest:$dest_dir

_lolify
if [[ "${range,,}" == "no" ]] && [[ "$name_format" == "no" ]]; then
    echo no changes to file names, skipping organizing
else
    echo organizing
    _organize
fi

echo Done.
